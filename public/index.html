<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bookshelf</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* A slightly softer slate-100 */
            color: #1e293b; /* slate-800 */
        }
        .book-card {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .book-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .shelf {
            min-height: 200px; /* Ensure shelves have some height even when empty */
            border-radius: 0.5rem;
            padding: 1rem;
            background-color: #e2e8f0; /* slate-200 for shelves */
            transition: border-color 0.2s ease;
        }
        .drag-over {
            border: 2px dashed #2563eb; /* blue-600 */
            background-color: #dbeafe; /* blue-100 */
        }
        [draggable="true"] {
            cursor: grab;
        }
        [draggable="true"]:active {
            cursor: grabbing;
        }
        /* Custom scrollbar for a cleaner look (optional) */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e2e8f0; /* slate-200 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }
        .search-result-card {
            transition: background-color 0.2s ease-in-out;
        }
        .search-result-card:hover {
            background-color: #f8fafc; /* slate-50 */
        }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .btn:active {
            transform: scale(0.98);
        }
        .btn-primary {
            background-color: #2563eb; /* blue-600 */
            color: white;
        }
        .btn-primary:hover {
            background-color: #1d4ed8; /* blue-700 */
        }
        .btn-secondary {
            background-color: #64748b; /* slate-500 */
            color: white;
        }
        .btn-secondary:hover {
            background-color: #475569; /* slate-600 */
        }
        .btn-disabled {
            background-color: #94a3b8; /* slate-400 */
            color: #e2e8f0; /* slate-200 */
            cursor: not-allowed;
        }
        /* Star rating styling */
        .star-rating {
            display: inline-flex;
            flex-direction: row-reverse;
            justify-content: flex-end;
        }
        .star-rating input[type="radio"] {
            display: none;
        }
        .star-rating label {
            font-size: 1.5rem;
            color: #d1d5db;
            cursor: pointer;
            padding: 0 0.125rem;
            transition: color 0.2s ease-in-out;
        }
        .star-rating input[type="radio"]:checked ~ label,
        .star-rating label:hover,
        .star-rating label:hover ~ label {
            color: #f59e0b;
        }
        .star-rating input[type="radio"]:not(:checked) ~ label:hover,
        .star-rating input[type="radio"]:not(:checked) ~ label:hover ~ label {
            color: #f59e0b;
        }
        /* Modal scrollbar styling */
        .modal-content::-webkit-scrollbar {
            width: 6px;
        }
        .modal-content::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }
        .modal-content::-webkit-scrollbar-track {
            background-color: #f1f5f9;
        }
    </style>
</head>
<body class="min-h-screen">
    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="mb-10 text-center">
            <h1 class="text-4xl md:text-5xl font-bold text-sky-600">Bookshelf</h1>
        </header>

        <section id="search-section" class="mb-12 bg-white p-6 rounded-xl shadow-xl">
            <h2 class="text-2xl font-semibold mb-4 text-sky-700">Search for Books</h2>
            <div class="flex gap-3 mb-6">
                <input type="text" id="search-input" placeholder="Search by title or author (e.g., Dune Frank Herbert)" class="flex-grow p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 outline-none transition-shadow">
                <button id="search-button" class="btn btn-primary">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
                    </svg>
                    Search
                </button>
            </div>
            <div id="search-results-container" class="space-y-4 max-h-[50vh] overflow-y-auto">
                </div>
        </section>

        <div id="bookDetailsModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
            <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden transform transition-all">
                <div class="px-6 py-4 bg-gray-50 border-b border-gray-200">
                    <div class="flex items-start justify-between">
                        <div>
                            <h3 class="text-xl font-semibold text-gray-800" id="modalBookTitle">Book Title</h3>
                            <p class="text-sm text-gray-500" id="modalBookAuthor">By Author Name</p>
                        </div>
                        <button id="closeModalBtn" class="text-gray-400 hover:text-gray-600 transition">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                </div>

                <div class="p-6 space-y-6 modal-content max-h-[calc(100vh-200px)] overflow-y-auto">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">My Rating (1-10)</label>
                        <div class="star-rating">
                            <input type="radio" id="star10" name="rating" value="10" /><label for="star10" title="10 stars">★</label>
                            <input type="radio" id="star9" name="rating" value="9" /><label for="star9" title="9 stars">★</label>
                            <input type="radio" id="star8" name="rating" value="8" /><label for="star8" title="8 stars">★</label>
                            <input type="radio" id="star7" name="rating" value="7" /><label for="star7" title="7 stars">★</label>
                            <input type="radio" id="star6" name="rating" value="6" /><label for="star6" title="6 stars">★</label>
                            <input type="radio" id="star5" name="rating" value="5" /><label for="star5" title="5 stars">★</label>
                            <input type="radio" id="star4" name="rating" value="4" /><label for="star4" title="4 stars">★</label>
                            <input type="radio" id="star3" name="rating" value="3" /><label for="star3" title="3 stars">★</label>
                            <input type="radio" id="star2" name="rating" value="2" /><label for="star2" title="2 stars">★</label>
                            <input type="radio" id="star1" name="rating" value="1" /><label for="star1" title="1 star">★</label>
                        </div>
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Book Type</label>
                        <div class="flex items-center space-x-4">
                            <label for="formatBook" class="flex items-center space-x-2 cursor-pointer p-2 rounded-md hover:bg-gray-100">
                                <input type="radio" id="formatBook" name="book_type" value="physical_book" class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                <span class="text-gray-700">Physical Book</span>
                            </label>
                            <label for="formatAudiobook" class="flex items-center space-x-2 cursor-pointer p-2 rounded-md hover:bg-gray-100">
                                <input type="radio" id="formatAudiobook" name="book_type" value="audiobook" class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                <span class="text-gray-700">Audiobook</span>
                            </label>
                            <label for="formatEbook" class="flex items-center space-x-2 cursor-pointer p-2 rounded-md hover:bg-gray-100">
                                <input type="radio" id="formatEbook" name="book_type" value="ebook" class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                <span class="text-gray-700">E-book</span>
                            </label>
                        </div>
                    </div>

                    <div>
                        <label for="comments" class="block text-sm font-medium text-gray-700">Comments / Review</label>
                        <textarea id="comments" name="comments" rows="4" class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2.5" placeholder="What did you think of this book? (Optional)"></textarea>
                        <p class="mt-1 text-xs text-gray-500">Your comments will be private unless you choose to share them.</p>
                    </div>
                </div>

                <div class="px-6 py-4 bg-gray-50 border-t border-gray-200 flex justify-end space-x-3">
                    <button type="button" id="cancelBtn" class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition">
                        Cancel
                    </button>
                    <button type="button" id="saveDetailsBtn" class="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-lg shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition">
                        Save Details
                    </button>
                </div>
            </div>
        </div>

        <section id="bookshelves-section" class="grid md:grid-cols-3 gap-x-6 gap-y-8">
            <div id="shelf-want_to_read" class="shelf-container">
                <h2 class="text-2xl font-semibold mb-4 text-amber-600">Want to Read</h2>
                <div id="want_to_read" class="shelf space-y-4" data-status="want_to_read">
                    </div>
            </div>

            <div id="shelf-currently_reading" class="shelf-container">
                <h2 class="text-2xl font-semibold mb-4 text-teal-600">Currently Reading</h2>
                <div id="currently_reading" class="shelf space-y-4" data-status="currently_reading">
                    </div>
            </div>

            <div id="shelf-read" class="shelf-container">
                <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Read</h2>
                <div id="read" class="shelf space-y-4" data-status="read">
                    </div>
            </div>
        </section>

        <div id="message-area" class="fixed bottom-5 right-5 z-50 space-y-2">
            </div>
    </div>

    <script>
        // API Base URL (ensure your Rails server is running here)
        const API_BASE_URL = 'http://localhost:3000/api/v1';

        // Store local books to check against search results and for UI updates
        let myBooks = [];
        let draggedBook = null; // To store the book being dragged

        // --- DOM Elements ---
        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-button');
        const searchResultsContainer = document.getElementById('search-results-container');
        const shelves = {
            want_to_read: document.getElementById('want_to_read'),
            currently_reading: document.getElementById('currently_reading'),
            read: document.getElementById('read')
        };
        const messageArea = document.getElementById('message-area');

        // --- Utility Functions ---
        function showMessage(text, type = 'success') {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = text;
            messageDiv.className = `p-3 rounded-lg shadow-md text-sm font-medium ${
                type === 'success' ? 'bg-green-500 text-white' :
                type === 'error' ? 'bg-red-500 text-white' :
                'bg-sky-500 text-white' // Default to info
            }`;
            messageArea.appendChild(messageDiv);
            setTimeout(() => {
                messageDiv.style.transition = 'opacity 0.5s ease';
                messageDiv.style.opacity = '0';
                setTimeout(() => messageDiv.remove(), 500);
            }, 3000);
        }

        // --- Book Card Creation ---
        function createBookCard(book, isSearchResult = false) {
            const card = document.createElement('div');
            card.className = `book-card bg-white p-4 rounded-lg shadow-md border border-slate-200 ${isSearchResult ? 'search-result-card' : ''}`;
            card.dataset.bookDbId = book.id; // This will be undefined for new books from search results until saved
            card.dataset.bookOlid = book.open_library_id;

            const title = book.title || 'No Title';
            // Ensure authors is treated as a string for display.
            // For books from your DB, 'book.author' should be the string.
            // For OpenLibrary results, 'book.authors' might be an array, or 'book.author_name'.
            let displayAuthors = 'Unknown Author';
            if (book.author) { // From your DB
                displayAuthors = book.author;
            } else if (Array.isArray(book.authors)) { // OpenLibrary array
                 displayAuthors = book.authors.join(', ');
            } else if (book.author_name) { // OpenLibrary string or array
                displayAuthors = Array.isArray(book.author_name) ? book.author_name.join(', ') : book.author_name;
            }


            const coverUrl = book.cover_image_url || book.cover_image_url_medium || book.cover_image_url_large || `https://placehold.co/80x120/e2e8f0/64748b?text=${encodeURIComponent(title.substring(0,10))}`;

            card.innerHTML = `
                <div class="flex gap-4">
                    <img src="${coverUrl}" alt="Cover of ${title}" class="w-20 h-30 object-cover rounded shadow-sm flex-shrink-0" onerror="this.onerror=null;this.src='https://placehold.co/80x120/e2e8f0/64748b?text=No+Cover';">
                    <div class="flex-grow">
                        <h3 class="font-semibold text-lg text-slate-700">${title}</h3>
                        <p class="text-sm text-slate-500 mb-1">By: ${displayAuthors}</p>
                        ${book.publication_year ? `<p class="text-xs text-slate-400">Published: ${book.publication_year}</p>` : ''}
                        ${!isSearchResult && book.rating ? `<p class="text-xs text-slate-400">Rating: ${book.rating}/10</p>` : ''}
                        ${!isSearchResult && book.book_type ? `<p class="text-xs text-slate-400">Format: ${book.book_type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</p>` : ''}
                        ${!isSearchResult && book.comments ? `<p class="text-xs text-slate-400 mt-1 italic">"${book.comments}"</p>` : ''}
                    </div>
                </div>
            `;

            if (isSearchResult) {
                const existingBook = myBooks.find(b =>
                    b.open_library_id === book.open_library_id ||
                    (b.isbn_13 && book.isbn_13 && b.isbn_13 === book.isbn_13) ||
                    (b.isbn_10 && book.isbn_10 && b.isbn_10 === book.isbn_10) ||
                    (b.title.toLowerCase() === book.title.toLowerCase() && (b.author || '').toLowerCase() === displayAuthors.toLowerCase())
                );


                if (existingBook) {
                    const statusButton = document.createElement('button');
                    statusButton.textContent = `On Shelf (${existingBook.status.replace(/_/g, ' ')})`;
                    statusButton.className = 'btn btn-disabled mt-3 w-full text-xs';
                    statusButton.disabled = true;
                    card.appendChild(statusButton);
                } else {
                    const quickAddContainer = document.createElement('div');
                    quickAddContainer.className = 'mt-3 flex gap-2';
                    
                    const buttons = [
                        { status: 'want_to_read', icon: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12Z" /></svg>`, text: 'Want to Read', color: 'amber'},
                        { status: 'currently_reading', icon: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6.042A8.967 8.967 0 0 0 6 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 0 1 6 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 0 1 6-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0 0 18 18a8.967 8.967 0 0 0-6 2.292m0-14.25v14.25" /></svg>`, text: 'Reading', color: 'teal'},
                        { status: 'read', icon: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" /></svg>`, text: 'Read', color: 'indigo'}
                    ];

                    buttons.forEach(({ status, icon, text, color }) => {
                        const button = document.createElement('button');
                        button.className = `btn flex-1 flex items-center justify-center gap-1 text-xs px-2 py-1.5 bg-${color}-50 hover:bg-${color}-100 text-${color}-700 border border-${color}-200 hover:border-${color}-300 transition-colors`;
                        button.innerHTML = `${icon}${text}`;
                        button.onclick = (e) => {
                            e.stopPropagation(); // Prevent card click if button is clicked
                            addBookToShelf(book, status);
                        };
                        quickAddContainer.appendChild(button);
                    });
                    card.appendChild(quickAddContainer);
                }
            } else {
                // This is a book on a shelf
                card.style.cursor = 'pointer';
                card.addEventListener('click', (e) => {
                    // Only prevent modal if a drag operation is currently active.
                    // The `draggedBook` variable is set during dragstart and cleared on dragend/drop.
                    if (draggedBook) {
                        // console.log('Modal opening prevented: drag operation active.');
                        return;
                    }
                    // Check if the click target is one of the quick add buttons (should not happen here, but good practice)
                    if (e.target.closest('.btn')) {
                        return;
                    }
                    
                    // console.log('Shelf book card clicked, opening modal for:', book); // For debugging
                    // e.preventDefault(); // Not strictly necessary unless the card is a link
                    openBookDetailsModal(book);
                });
                
                card.draggable = true;
                card.ondragstart = (event) => {
                    // event.stopPropagation(); // This can sometimes interfere with the click event not firing after drag.
                                            // Let's test without it first, as draggedBook check should suffice.
                                            // The main goal is to set draggedBook.
                    handleDragStart(event, book);
                };
            }
            return card;
        }

        // --- API Interaction Functions ---
        async function fetchMyBooks() {
            try {
                const response = await fetch(`${API_BASE_URL}/books`);
                if (!response.ok) throw new Error(`Failed to fetch books: ${response.status} ${response.statusText}`);
                myBooks = await response.json();
                renderBookshelves();
            } catch (error) {
                console.error('Error fetching books:', error);
                showMessage(`Error fetching your books: ${error.message}`, 'error');
            }
        }

        async function performSearch(query) {
            if (!query.trim()) {
                searchResultsContainer.innerHTML = '<p class="text-slate-500 text-center">Enter a search term above.</p>';
                return;
            }
            searchResultsContainer.innerHTML = '<p class="text-slate-500 text-center animate-pulse">Searching...</p>';
            try {
                // Construct authors from OpenLibrary's author_name field for the payload
                let authorsForPayload = bookDataFromSearch.author_name;
                if (Array.isArray(authorsForPayload)) {
                    authorsForPayload = authorsForPayload.join(', ');
                }

                const response = await fetch(`${API_BASE_URL}/search?query=${encodeURIComponent(query)}`);
                if (!response.ok) throw new Error(`Search failed: ${response.status} ${response.statusText}`);
                const results = await response.json();
                renderSearchResults(results);
            } catch (error) {
                console.error('Error performing search:', error);
                searchResultsContainer.innerHTML = `<p class="text-red-500 text-center">Search error: ${error.message}</p>`;
                showMessage(`Search error: ${error.message}`, 'error');
            }
        }

        async function addBookToShelf(bookDataFromSearch, newStatus) {
            // Prepare data for our Book model
            // Ensure author is a string, as expected by Rails backend
            let authorString = 'Unknown Author';
            if (Array.isArray(bookDataFromSearch.authors)) { // From some search APIs
                authorString = bookDataFromSearch.authors.join(', ');
            } else if (bookDataFromSearch.authors) { // String from some search APIs
                authorString = bookDataFromSearch.authors;
            } else if (Array.isArray(bookDataFromSearch.author_name)) { // From OpenLibrary
                authorString = bookDataFromSearch.author_name.join(', ');
            } else if (bookDataFromSearch.author_name) { // String from OpenLibrary
                authorString = bookDataFromSearch.author_name;
            }


            const newBookPayload = {
                book: {
                    title: bookDataFromSearch.title,
                    author: authorString,
                    isbn_13: bookDataFromSearch.isbn_13 ? bookDataFromSearch.isbn_13[0] : (bookDataFromSearch.isbn ? bookDataFromSearch.isbn[0] : null), // OL often returns arrays
                    isbn_10: bookDataFromSearch.isbn_10 ? bookDataFromSearch.isbn_10[0] : (bookDataFromSearch.isbn ? bookDataFromSearch.isbn.find(i => i.length === 10) : null), // OL often returns arrays
                    publication_year: bookDataFromSearch.first_publish_year || bookDataFromSearch.publication_year, // OL uses first_publish_year
                    page_count: bookDataFromSearch.number_of_pages_median || bookDataFromSearch.page_count, // OL uses number_of_pages_median
                    cover_image_url: bookDataFromSearch.cover_i ? `https://covers.openlibrary.org/b/id/${bookDataFromSearch.cover_i}-L.jpg` : (bookDataFromSearch.cover_image_url || null), // OL uses cover_i
                    open_library_id: bookDataFromSearch.key ? bookDataFromSearch.key.replace("/works/", "") : bookDataFromSearch.open_library_id, // OL uses key
                    status: newStatus,
                    book_type: 'physical_book', // Default
                    date_added: new Date().toISOString()
                }
            };
            
            // Clean up undefined fields to avoid sending them as null if not desired by backend
            for (const key in newBookPayload.book) {
                if (newBookPayload.book[key] === undefined) {
                    delete newBookPayload.book[key];
                }
            }


            try {
                const response = await fetch(`${API_BASE_URL}/books`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newBookPayload)
                });
                if (!response.ok) {
                    const errorData = await response.json(); 
                    const errorMessage = errorData.errors ? JSON.stringify(errorData.errors) : `Server error ${response.status}`;
                    throw new Error(`Failed to add book: ${errorMessage}`);
                }
                const addedBook = await response.json();
                myBooks.push(addedBook); 
                renderBookshelves(); 
                showMessage(`"${addedBook.title}" added to "${newStatus.replace(/_/g, ' ')}"`, 'success');
                
                // Update the search result card to show it's on a shelf
                const olIdToFind = bookDataFromSearch.key ? bookDataFromSearch.key.replace("/works/", "") : bookDataFromSearch.open_library_id;
                const searchResultCard = document.querySelector(`[data-book-olid="${olIdToFind}"]`);

                if (searchResultCard) {
                    const quickAddContainer = searchResultCard.querySelector('.flex.gap-2'); // The container of quick add buttons
                    if (quickAddContainer) {
                        quickAddContainer.innerHTML = ''; // Clear buttons
                        const statusButton = document.createElement('button');
                        statusButton.textContent = `On Shelf (${newStatus.replace(/_/g, ' ')})`;
                        statusButton.className = 'btn btn-disabled mt-0 w-full text-xs'; // Adjusted mt-0 as it's replacing buttons
                        statusButton.disabled = true;
                        quickAddContainer.appendChild(statusButton);
                    }
                }


            } catch (error) {
                console.error('Error adding book:', error);
                showMessage(`Error adding book: ${error.message}`, 'error');
            }
        }

        async function updateBookStatus(bookId, newStatus) {
            if (!bookId) {
                console.error('updateBookStatus called with invalid bookId:', bookId);
                showMessage('Could not update book: Invalid book ID.', 'error');
                fetchMyBooks();
                return;
            }
            try {
                const response = await fetch(`${API_BASE_URL}/books/${bookId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ book: { status: newStatus } })
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    const errorMessage = errorData.errors ? JSON.stringify(errorData.errors) : `Server error ${response.status}`;
                    throw new Error(`Failed to update book status: ${errorMessage}`);
                }
                const updatedBook = await response.json();
                const bookIndex = myBooks.findIndex(b => b.id === updatedBook.id);
                if (bookIndex !== -1) {
                    myBooks[bookIndex] = updatedBook;
                } else { 
                    myBooks.push(updatedBook);
                }
                renderBookshelves(); 
                showMessage(`Book moved to "${newStatus.replace(/_/g, ' ')}"`, 'success');
            } catch (error) {
                console.error('Error updating book status:', error);
                showMessage(`Error updating book: ${error.message}`, 'error');
                fetchMyBooks(); 
            }
        }

        // --- Rendering Functions ---
        function renderBookshelves() {
            Object.values(shelves).forEach(shelfEl => shelfEl.innerHTML = ''); 

            myBooks.forEach(book => {
                if (book.status && shelves[book.status]) {
                    const card = createBookCard(book, false); 
                    shelves[book.status].appendChild(card);
                }
            });
        }

        function renderSearchResults(results) {
            searchResultsContainer.innerHTML = ''; 
            if (!results || !Array.isArray(results) || results.length === 0) { // Check if results is an array
                searchResultsContainer.innerHTML = '<p class="text-slate-500 text-center">No books found for your query.</p>';
                return;
            }
            results.forEach(bookData => {
                // Normalize OpenLibrary data for consistency with createBookCard expectations
                const normalizedBookData = {
                    title: bookData.title,
                    authors: bookData.author_name, // createBookCard expects 'authors' or 'author_name'
                    author_name: bookData.author_name,
                    publication_year: bookData.first_publish_year,
                    isbn_13: bookData.isbn, // Assuming isbn array might contain 13-digit
                    isbn_10: bookData.isbn, // Assuming isbn array might contain 10-digit
                    page_count: bookData.number_of_pages_median,
                    cover_image_url: bookData.cover_i ? `https://covers.openlibrary.org/b/id/${bookData.cover_i}-M.jpg` : null, // Medium size cover
                    open_library_id: bookData.key ? bookData.key.replace("/works/", "") : null, // Extract OLID from key
                    // Pass the original OL key for accurate identification if needed later
                    open_library_work_key: bookData.key 
                };
                if (!normalizedBookData.open_library_id && bookData.lending_edition_s) { // Fallback for OLID if key is missing
                    normalizedBookData.open_library_id = bookData.lending_edition_s;
                }


                const card = createBookCard(normalizedBookData, true); 
                searchResultsContainer.appendChild(card);
            });
        }

        // --- Drag and Drop Handlers ---
        function handleDragStart(event, book) {
            if (!book || !book.id) {
                console.error("Drag start on book with no ID:", book);
                event.preventDefault(); 
                return;
            }
            draggedBook = book; // Set the global draggedBook object
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', book.id.toString()); 
            event.target.classList.add('opacity-50');
        }

        function handleDragOver(event) {
            event.preventDefault(); 
            event.dataTransfer.dropEffect = 'move';
            const targetShelf = event.target.closest('.shelf');
            if (targetShelf) {
                Object.values(shelves).forEach(s => s.classList.remove('drag-over'));
                targetShelf.classList.add('drag-over');
            }
        }

        function handleDragLeave(event) {
            const targetShelf = event.target.closest('.shelf');
            if (targetShelf && !targetShelf.contains(event.relatedTarget) && event.relatedTarget !== targetShelf) {
                 targetShelf.classList.remove('drag-over');
            } else if (!targetShelf) { // If leaving the general area of shelves
                 Object.values(shelves).forEach(s => s.classList.remove('drag-over'));
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            const targetShelfElement = event.target.closest('.shelf');
            targetShelfElement.classList.remove('drag-over'); // Always remove drag-over class

            if (targetShelfElement && draggedBook && draggedBook.id) {
                const newStatus = targetShelfElement.dataset.status;
                if (draggedBook.status !== newStatus) {
                    updateBookStatus(draggedBook.id, newStatus);
                }
            } else {
                console.warn("Drop event occurred without a valid target shelf or dragged book ID.");
            }
            // draggedBook is cleared in handleDragEnd
        }

        function handleDragEnd(event) {
            if (event.target.classList.contains('book-card')) {
                 event.target.classList.remove('opacity-50');
            }
            Object.values(shelves).forEach(shelfEl => shelfEl.classList.remove('drag-over'));
            draggedBook = null; // CRITICAL: Clear draggedBook here
        }

        // --- Event Listeners ---
        searchButton.addEventListener('click', () => {
            performSearch(searchInput.value);
        });
        searchInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                performSearch(searchInput.value);
            }
        });

        Object.values(shelves).forEach(shelfEl => {
            shelfEl.addEventListener('dragover', handleDragOver);
            shelfEl.addEventListener('dragleave', handleDragLeave);
            shelfEl.addEventListener('drop', handleDrop);
        });
        document.addEventListener('dragend', handleDragEnd);


        // --- Book Details Modal Functions ---
        let currentBookForModal = null; // Store the whole book object for the modal

        function openBookDetailsModal(book) {
            // console.log('Opening modal for book:', book); 
            currentBookForModal = book; // Store the book object
            document.getElementById('modalBookTitle').textContent = book.title || 'N/A';
            
            // Determine author string for modal
            let authorForModal = 'Unknown Author';
            if (book.author) { // From DB
                authorForModal = book.author;
            } else if (Array.isArray(book.authors)) { // From search (OpenLibrary)
                 authorForModal = book.authors.join(', ');
            } else if (book.author_name) { // From search (OpenLibrary, can be string or array)
                authorForModal = Array.isArray(book.author_name) ? book.author_name.join(', ') : book.author_name;
            }
            document.getElementById('modalBookAuthor').textContent = `By ${authorForModal}`;
            
            document.querySelectorAll('input[name="rating"]').forEach(input => input.checked = false);
            document.querySelectorAll('input[name="book_type"]').forEach(input => input.checked = false);
            document.getElementById('comments').value = '';
            
            if (book.rating) {
                const ratingInput = document.querySelector(`input[name="rating"][value="${book.rating}"]`);
                if (ratingInput) ratingInput.checked = true;
            }
            if (book.book_type) {
                const typeInput = document.querySelector(`input[name="book_type"][value="${book.book_type}"]`);
                if (typeInput) typeInput.checked = true;
            } else {
                document.querySelector('input[name="book_type"][value="physical_book"]').checked = true; // Default
            }
            if (book.comments) {
                document.getElementById('comments').value = book.comments;
            }
            
            const modal = document.getElementById('bookDetailsModal');
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }

        function closeBookDetailsModal() {
            document.getElementById('bookDetailsModal').classList.add('hidden');
            document.body.style.overflow = '';
            currentBookForModal = null; // Clear the stored book
        }

        async function saveBookDetails() {
            if (!currentBookForModal || !currentBookForModal.id) { // Check for book and its ID
                showMessage('No book selected or book has no ID to save details.', 'error');
                return;
            }

            const rating = document.querySelector('input[name="rating"]:checked')?.value;
            const bookType = document.querySelector('input[name="book_type"]:checked')?.value;
            const comments = document.getElementById('comments').value;

            try {
                const response = await fetch(`${API_BASE_URL}/books/${currentBookForModal.id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        book: {
                            rating: rating ? parseInt(rating) : null,
                            book_type: bookType,
                            comments: comments
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    const errorMessage = errorData.errors ? JSON.stringify(errorData.errors) : `Server error ${response.status}`;
                    throw new Error(`Failed to update book details: ${errorMessage}`);
                }
                
                const updatedBook = await response.json();
                const bookIndex = myBooks.findIndex(b => b.id === updatedBook.id);
                if (bookIndex !== -1) {
                    myBooks[bookIndex] = updatedBook;
                }
                
                renderBookshelves();
                showMessage('Book details updated successfully!', 'success');
                closeBookDetailsModal();
            } catch (error) {
                console.error('Error updating book details:', error);
                showMessage(`Error updating book details: ${error.message}`, 'error');
            }
        }

        document.getElementById('closeModalBtn').addEventListener('click', closeBookDetailsModal);
        document.getElementById('cancelBtn').addEventListener('click', closeBookDetailsModal);
        document.getElementById('saveDetailsBtn').addEventListener('click', saveBookDetails);

        document.getElementById('bookDetailsModal').addEventListener('click', (event) => {
            if (event.target === document.getElementById('bookDetailsModal')) {
                closeBookDetailsModal();
            }
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && !document.getElementById('bookDetailsModal').classList.contains('hidden')) {
                closeBookDetailsModal();
            }
        });

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            fetchMyBooks();
            searchResultsContainer.innerHTML = '<p class="text-slate-500 text-center">Search for books to add to your shelves.</p>';
        });
    </script>
</body>
</html>
